// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClassInfo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ClassInfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ClassInfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ClassInfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ClassInfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ClassInfo_2eproto;
namespace tutorial {
class ClassInfo;
class ClassInfoDefaultTypeInternal;
extern ClassInfoDefaultTypeInternal _ClassInfo_default_instance_;
class Student;
class StudentDefaultTypeInternal;
extern StudentDefaultTypeInternal _Student_default_instance_;
class StudentRequest;
class StudentRequestDefaultTypeInternal;
extern StudentRequestDefaultTypeInternal _StudentRequest_default_instance_;
class StudentRespond;
class StudentRespondDefaultTypeInternal;
extern StudentRespondDefaultTypeInternal _StudentRespond_default_instance_;
class Subject;
class SubjectDefaultTypeInternal;
extern SubjectDefaultTypeInternal _Subject_default_instance_;
}  // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template<> ::tutorial::ClassInfo* Arena::CreateMaybeMessage<::tutorial::ClassInfo>(Arena*);
template<> ::tutorial::Student* Arena::CreateMaybeMessage<::tutorial::Student>(Arena*);
template<> ::tutorial::StudentRequest* Arena::CreateMaybeMessage<::tutorial::StudentRequest>(Arena*);
template<> ::tutorial::StudentRespond* Arena::CreateMaybeMessage<::tutorial::StudentRespond>(Arena*);
template<> ::tutorial::Subject* Arena::CreateMaybeMessage<::tutorial::Subject>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum Student_GenderType : int {
  Student_GenderType_GT_BOY = 0,
  Student_GenderType_GT_GIRL = 1,
  Student_GenderType_Student_GenderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Student_GenderType_Student_GenderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Student_GenderType_IsValid(int value);
constexpr Student_GenderType Student_GenderType_GenderType_MIN = Student_GenderType_GT_BOY;
constexpr Student_GenderType Student_GenderType_GenderType_MAX = Student_GenderType_GT_GIRL;
constexpr int Student_GenderType_GenderType_ARRAYSIZE = Student_GenderType_GenderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Student_GenderType_descriptor();
template<typename T>
inline const std::string& Student_GenderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Student_GenderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Student_GenderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Student_GenderType_descriptor(), enum_t_value);
}
inline bool Student_GenderType_Parse(
    const std::string& name, Student_GenderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Student_GenderType>(
    Student_GenderType_descriptor(), name, value);
}
// ===================================================================

class Subject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Subject) */ {
 public:
  Subject();
  virtual ~Subject();

  Subject(const Subject& from);
  Subject(Subject&& from) noexcept
    : Subject() {
    *this = ::std::move(from);
  }

  inline Subject& operator=(const Subject& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subject& operator=(Subject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Subject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Subject* internal_default_instance() {
    return reinterpret_cast<const Subject*>(
               &_Subject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Subject* other);
  friend void swap(Subject& a, Subject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Subject* New() const final {
    return CreateMaybeMessage<Subject>(nullptr);
  }

  Subject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Subject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Subject& from);
  void MergeFrom(const Subject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Subject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClassInfo_2eproto);
    return ::descriptor_table_ClassInfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string major = 1;
  void clear_major();
  static const int kMajorFieldNumber = 1;
  const std::string& major() const;
  void set_major(const std::string& value);
  void set_major(std::string&& value);
  void set_major(const char* value);
  void set_major(const char* value, size_t size);
  std::string* mutable_major();
  std::string* release_major();
  void set_allocated_major(std::string* major);

  // float score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:tutorial.Subject)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr major_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ClassInfo_2eproto;
};
// -------------------------------------------------------------------

class Student :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Student) */ {
 public:
  Student();
  virtual ~Student();

  Student(const Student& from);
  Student(Student&& from) noexcept
    : Student() {
    *this = ::std::move(from);
  }

  inline Student& operator=(const Student& from) {
    CopyFrom(from);
    return *this;
  }
  inline Student& operator=(Student&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Student& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Student* internal_default_instance() {
    return reinterpret_cast<const Student*>(
               &_Student_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Student* other);
  friend void swap(Student& a, Student& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Student* New() const final {
    return CreateMaybeMessage<Student>(nullptr);
  }

  Student* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Student>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Student& from);
  void MergeFrom(const Student& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Student* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Student";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClassInfo_2eproto);
    return ::descriptor_table_ClassInfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Student_GenderType GenderType;
  static constexpr GenderType GT_BOY =
    Student_GenderType_GT_BOY;
  static constexpr GenderType GT_GIRL =
    Student_GenderType_GT_GIRL;
  static inline bool GenderType_IsValid(int value) {
    return Student_GenderType_IsValid(value);
  }
  static constexpr GenderType GenderType_MIN =
    Student_GenderType_GenderType_MIN;
  static constexpr GenderType GenderType_MAX =
    Student_GenderType_GenderType_MAX;
  static constexpr int GenderType_ARRAYSIZE =
    Student_GenderType_GenderType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GenderType_descriptor() {
    return Student_GenderType_descriptor();
  }
  template<typename T>
  static inline const std::string& GenderType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GenderType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GenderType_Name.");
    return Student_GenderType_Name(enum_t_value);
  }
  static inline bool GenderType_Parse(const std::string& name,
      GenderType* value) {
    return Student_GenderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .tutorial.Subject subjects = 5;
  int subjects_size() const;
  void clear_subjects();
  static const int kSubjectsFieldNumber = 5;
  ::tutorial::Subject* mutable_subjects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Subject >*
      mutable_subjects();
  const ::tutorial::Subject& subjects(int index) const;
  ::tutorial::Subject* add_subjects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Subject >&
      subjects() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string homeAddress = 4;
  void clear_homeaddress();
  static const int kHomeAddressFieldNumber = 4;
  const std::string& homeaddress() const;
  void set_homeaddress(const std::string& value);
  void set_homeaddress(std::string&& value);
  void set_homeaddress(const char* value);
  void set_homeaddress(const char* value, size_t size);
  std::string* mutable_homeaddress();
  std::string* release_homeaddress();
  void set_allocated_homeaddress(std::string* homeaddress);

  // int32 age = 2;
  void clear_age();
  static const int kAgeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 age() const;
  void set_age(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .tutorial.Student.GenderType gender = 3;
  void clear_gender();
  static const int kGenderFieldNumber = 3;
  ::tutorial::Student_GenderType gender() const;
  void set_gender(::tutorial::Student_GenderType value);

  // int32 id = 6;
  void clear_id();
  static const int kIdFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tutorial.Student)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Subject > subjects_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homeaddress_;
  ::PROTOBUF_NAMESPACE_ID::int32 age_;
  int gender_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ClassInfo_2eproto;
};
// -------------------------------------------------------------------

class StudentRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.StudentRequest) */ {
 public:
  StudentRequest();
  virtual ~StudentRequest();

  StudentRequest(const StudentRequest& from);
  StudentRequest(StudentRequest&& from) noexcept
    : StudentRequest() {
    *this = ::std::move(from);
  }

  inline StudentRequest& operator=(const StudentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StudentRequest& operator=(StudentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StudentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StudentRequest* internal_default_instance() {
    return reinterpret_cast<const StudentRequest*>(
               &_StudentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(StudentRequest* other);
  friend void swap(StudentRequest& a, StudentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StudentRequest* New() const final {
    return CreateMaybeMessage<StudentRequest>(nullptr);
  }

  StudentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StudentRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StudentRequest& from);
  void MergeFrom(const StudentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StudentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.StudentRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClassInfo_2eproto);
    return ::descriptor_table_ClassInfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tutorial.StudentRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ClassInfo_2eproto;
};
// -------------------------------------------------------------------

class StudentRespond :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.StudentRespond) */ {
 public:
  StudentRespond();
  virtual ~StudentRespond();

  StudentRespond(const StudentRespond& from);
  StudentRespond(StudentRespond&& from) noexcept
    : StudentRespond() {
    *this = ::std::move(from);
  }

  inline StudentRespond& operator=(const StudentRespond& from) {
    CopyFrom(from);
    return *this;
  }
  inline StudentRespond& operator=(StudentRespond&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StudentRespond& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StudentRespond* internal_default_instance() {
    return reinterpret_cast<const StudentRespond*>(
               &_StudentRespond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StudentRespond* other);
  friend void swap(StudentRespond& a, StudentRespond& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StudentRespond* New() const final {
    return CreateMaybeMessage<StudentRespond>(nullptr);
  }

  StudentRespond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StudentRespond>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StudentRespond& from);
  void MergeFrom(const StudentRespond& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StudentRespond* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.StudentRespond";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClassInfo_2eproto);
    return ::descriptor_table_ClassInfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tutorial.Student student = 1;
  bool has_student() const;
  void clear_student();
  static const int kStudentFieldNumber = 1;
  const ::tutorial::Student& student() const;
  ::tutorial::Student* release_student();
  ::tutorial::Student* mutable_student();
  void set_allocated_student(::tutorial::Student* student);

  // @@protoc_insertion_point(class_scope:tutorial.StudentRespond)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::tutorial::Student* student_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ClassInfo_2eproto;
};
// -------------------------------------------------------------------

class ClassInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.ClassInfo) */ {
 public:
  ClassInfo();
  virtual ~ClassInfo();

  ClassInfo(const ClassInfo& from);
  ClassInfo(ClassInfo&& from) noexcept
    : ClassInfo() {
    *this = ::std::move(from);
  }

  inline ClassInfo& operator=(const ClassInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClassInfo& operator=(ClassInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClassInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassInfo* internal_default_instance() {
    return reinterpret_cast<const ClassInfo*>(
               &_ClassInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ClassInfo* other);
  friend void swap(ClassInfo& a, ClassInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassInfo* New() const final {
    return CreateMaybeMessage<ClassInfo>(nullptr);
  }

  ClassInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClassInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClassInfo& from);
  void MergeFrom(const ClassInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClassInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.ClassInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClassInfo_2eproto);
    return ::descriptor_table_ClassInfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tutorial.Student students = 1;
  int students_size() const;
  void clear_students();
  static const int kStudentsFieldNumber = 1;
  ::tutorial::Student* mutable_students(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Student >*
      mutable_students();
  const ::tutorial::Student& students(int index) const;
  ::tutorial::Student* add_students();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Student >&
      students() const;

  // @@protoc_insertion_point(class_scope:tutorial.ClassInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Student > students_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ClassInfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Subject

// string major = 1;
inline void Subject::clear_major() {
  major_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Subject::major() const {
  // @@protoc_insertion_point(field_get:tutorial.Subject.major)
  return major_.GetNoArena();
}
inline void Subject::set_major(const std::string& value) {
  
  major_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tutorial.Subject.major)
}
inline void Subject::set_major(std::string&& value) {
  
  major_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.Subject.major)
}
inline void Subject::set_major(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  major_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.Subject.major)
}
inline void Subject::set_major(const char* value, size_t size) {
  
  major_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.Subject.major)
}
inline std::string* Subject::mutable_major() {
  
  // @@protoc_insertion_point(field_mutable:tutorial.Subject.major)
  return major_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Subject::release_major() {
  // @@protoc_insertion_point(field_release:tutorial.Subject.major)
  
  return major_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Subject::set_allocated_major(std::string* major) {
  if (major != nullptr) {
    
  } else {
    
  }
  major_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), major);
  // @@protoc_insertion_point(field_set_allocated:tutorial.Subject.major)
}

// float score = 2;
inline void Subject::clear_score() {
  score_ = 0;
}
inline float Subject::score() const {
  // @@protoc_insertion_point(field_get:tutorial.Subject.score)
  return score_;
}
inline void Subject::set_score(float value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:tutorial.Subject.score)
}

// -------------------------------------------------------------------

// Student

// int32 id = 6;
inline void Student::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Student::id() const {
  // @@protoc_insertion_point(field_get:tutorial.Student.id)
  return id_;
}
inline void Student::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:tutorial.Student.id)
}

// string name = 1;
inline void Student::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Student::name() const {
  // @@protoc_insertion_point(field_get:tutorial.Student.name)
  return name_.GetNoArena();
}
inline void Student::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tutorial.Student.name)
}
inline void Student::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.Student.name)
}
inline void Student::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.Student.name)
}
inline void Student::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.Student.name)
}
inline std::string* Student::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tutorial.Student.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Student::release_name() {
  // @@protoc_insertion_point(field_release:tutorial.Student.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Student::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tutorial.Student.name)
}

// int32 age = 2;
inline void Student::clear_age() {
  age_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Student::age() const {
  // @@protoc_insertion_point(field_get:tutorial.Student.age)
  return age_;
}
inline void Student::set_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:tutorial.Student.age)
}

// .tutorial.Student.GenderType gender = 3;
inline void Student::clear_gender() {
  gender_ = 0;
}
inline ::tutorial::Student_GenderType Student::gender() const {
  // @@protoc_insertion_point(field_get:tutorial.Student.gender)
  return static_cast< ::tutorial::Student_GenderType >(gender_);
}
inline void Student::set_gender(::tutorial::Student_GenderType value) {
  
  gender_ = value;
  // @@protoc_insertion_point(field_set:tutorial.Student.gender)
}

// string homeAddress = 4;
inline void Student::clear_homeaddress() {
  homeaddress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Student::homeaddress() const {
  // @@protoc_insertion_point(field_get:tutorial.Student.homeAddress)
  return homeaddress_.GetNoArena();
}
inline void Student::set_homeaddress(const std::string& value) {
  
  homeaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tutorial.Student.homeAddress)
}
inline void Student::set_homeaddress(std::string&& value) {
  
  homeaddress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tutorial.Student.homeAddress)
}
inline void Student::set_homeaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  homeaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tutorial.Student.homeAddress)
}
inline void Student::set_homeaddress(const char* value, size_t size) {
  
  homeaddress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tutorial.Student.homeAddress)
}
inline std::string* Student::mutable_homeaddress() {
  
  // @@protoc_insertion_point(field_mutable:tutorial.Student.homeAddress)
  return homeaddress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Student::release_homeaddress() {
  // @@protoc_insertion_point(field_release:tutorial.Student.homeAddress)
  
  return homeaddress_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Student::set_allocated_homeaddress(std::string* homeaddress) {
  if (homeaddress != nullptr) {
    
  } else {
    
  }
  homeaddress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), homeaddress);
  // @@protoc_insertion_point(field_set_allocated:tutorial.Student.homeAddress)
}

// repeated .tutorial.Subject subjects = 5;
inline int Student::subjects_size() const {
  return subjects_.size();
}
inline void Student::clear_subjects() {
  subjects_.Clear();
}
inline ::tutorial::Subject* Student::mutable_subjects(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.Student.subjects)
  return subjects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Subject >*
Student::mutable_subjects() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.Student.subjects)
  return &subjects_;
}
inline const ::tutorial::Subject& Student::subjects(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Student.subjects)
  return subjects_.Get(index);
}
inline ::tutorial::Subject* Student::add_subjects() {
  // @@protoc_insertion_point(field_add:tutorial.Student.subjects)
  return subjects_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Subject >&
Student::subjects() const {
  // @@protoc_insertion_point(field_list:tutorial.Student.subjects)
  return subjects_;
}

// -------------------------------------------------------------------

// StudentRequest

// int32 id = 2;
inline void StudentRequest::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StudentRequest::id() const {
  // @@protoc_insertion_point(field_get:tutorial.StudentRequest.id)
  return id_;
}
inline void StudentRequest::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:tutorial.StudentRequest.id)
}

// -------------------------------------------------------------------

// StudentRespond

// .tutorial.Student student = 1;
inline bool StudentRespond::has_student() const {
  return this != internal_default_instance() && student_ != nullptr;
}
inline void StudentRespond::clear_student() {
  if (GetArenaNoVirtual() == nullptr && student_ != nullptr) {
    delete student_;
  }
  student_ = nullptr;
}
inline const ::tutorial::Student& StudentRespond::student() const {
  const ::tutorial::Student* p = student_;
  // @@protoc_insertion_point(field_get:tutorial.StudentRespond.student)
  return p != nullptr ? *p : *reinterpret_cast<const ::tutorial::Student*>(
      &::tutorial::_Student_default_instance_);
}
inline ::tutorial::Student* StudentRespond::release_student() {
  // @@protoc_insertion_point(field_release:tutorial.StudentRespond.student)
  
  ::tutorial::Student* temp = student_;
  student_ = nullptr;
  return temp;
}
inline ::tutorial::Student* StudentRespond::mutable_student() {
  
  if (student_ == nullptr) {
    auto* p = CreateMaybeMessage<::tutorial::Student>(GetArenaNoVirtual());
    student_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tutorial.StudentRespond.student)
  return student_;
}
inline void StudentRespond::set_allocated_student(::tutorial::Student* student) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete student_;
  }
  if (student) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      student = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, student, submessage_arena);
    }
    
  } else {
    
  }
  student_ = student;
  // @@protoc_insertion_point(field_set_allocated:tutorial.StudentRespond.student)
}

// -------------------------------------------------------------------

// ClassInfo

// repeated .tutorial.Student students = 1;
inline int ClassInfo::students_size() const {
  return students_.size();
}
inline void ClassInfo::clear_students() {
  students_.Clear();
}
inline ::tutorial::Student* ClassInfo::mutable_students(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.ClassInfo.students)
  return students_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Student >*
ClassInfo::mutable_students() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.ClassInfo.students)
  return &students_;
}
inline const ::tutorial::Student& ClassInfo::students(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.ClassInfo.students)
  return students_.Get(index);
}
inline ::tutorial::Student* ClassInfo::add_students() {
  // @@protoc_insertion_point(field_add:tutorial.ClassInfo.students)
  return students_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Student >&
ClassInfo::students() const {
  // @@protoc_insertion_point(field_list:tutorial.ClassInfo.students)
  return students_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tutorial::Student_GenderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::Student_GenderType>() {
  return ::tutorial::Student_GenderType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ClassInfo_2eproto
